---
title: How to use model builder consumption code
description: Learn how to use project templates provided by Model Builder to consume machine learning models.
author: luisquintanilla
ms.author: luquinta
ms.date: 08/24/2021
ms.custom: mvc, how-to
#Customer intent: As a developer, I want to use Model Builder project templates to consume my machine learning model.
---

# How to use model builder consumption code

Learn how to use project templates provided by Model Builder to consume your model and make predictions on new data.

## Model Builder project templates

Once you've trained a model using Model Builder, you'll want to use it to make predictions on new data. In the Model Builder window **Consume** step, Model Builder simplifies model consumption by providing two .NET application templates.

:::image type="content" source="media/consume-model-builder/model-builder-consume-step.png" alt-text="Model Builder Consume Step":::

- **Console**: C# .NET Console application
- **Web API**: C# ASP.NET Core Web API

## Add console application to solution

To generate a console application to consume your model, in the Project templates section of the Model Builder Consume step, select **Add to solution** on the Console app.

The application template generates a C# .NET Console application. When the project is added to your solution, it copies over the *mbconfig* file containing your trained model and respective training pipeline and consumption code-behind files. Additionally, it creates a *Program.cs* file which is the entry-point of the application. The generated code looks similar to the following:

```csharp
// This file was auto-generated by ML.NET Model Builder. 

using System;

namespace SentimentModelConsole
{
    class Program
    {
        static void Main(string[] args)
        {
            // Create single instance of sample data from first line of dataset for model input
            SentimentModel.ModelInput sampleData = new SentimentModel.ModelInput()
            {
                Comment = @"Wow... Loved this place.",
            };

            // Make a single prediction on the sample data and print results
            var predictionResult = SentimentModel.Predict(sampleData);

            Console.WriteLine("Using model to make single prediction -- Comparing actual Sentiment with predicted Sentiment from sample data...\n\n");


            Console.WriteLine($"Comment: {sampleData.Comment}");


            Console.WriteLine($"\n\nPredicted Sentiment: {predictionResult.Prediction}\n\n");
            Console.WriteLine("=============== End of process, hit any key to finish ===============");
            Console.ReadKey();
        }
    }
}
```

The generated code:

1. Creates a new data instance to make predictions on. In this example, since I'm trying to classify the sentiment of a comment, the schema of my input data is defined by the `SentimentModel.ModelInput` class which contains a field (column) called `Comment`.
1. Calls the `Predict` method in the *\*.consumption.cs* code-behind file. The `Predict` method uses your trained model create a `PredictionEngine`. Input data is passed into the PredictionEngine resulting in a prediction.
1. The results of the prediction are output are output to the console.

## Add Web API to solution

To generate a Web API to consume your model, in the Project templates section of the Model Builder Consume step, select **Add to solution** on the Web API.

The Web API application template is a C# ASP.NET Core Web API application. Compared to traditional ASP.NET Web API templates, the template included in Model Builder simplifies the project structure by defining configurations and routes in a single page using a technique known as Route-to-code. See [basic JSON APIs with Route-to-code in ASP.NET Core](/aspnet/core/web-api/route-to-code) for more information.

The project consists of a single file, *Program.cs* that looks like the following:

```csharp
// This file was auto-generated by ML.NET Model Builder. 
using System.IO;
using System.Text.Json;
using System.Threading.Tasks;
using Microsoft.AspNetCore;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.ML;
namespace SentimentModelWebAPI
{
    public class Program
    {
        public static void Main(string[] args)
        {
            //Configuration
            WebHost.CreateDefaultBuilder()
              .ConfigureServices(services =>
              {
                // Register Prediction Engine Pool
                services.AddPredictionEnginePool<SentimentModel.ModelInput, SentimentModel.ModelOutput>().FromFile("SentimentModel.zip");
              })
              .Configure(options =>
              {
                  options.UseRouting();
                  options.UseEndpoints(routes =>
                  {
                    // Define prediction endpoint
                    routes.MapPost("/predict", PredictHandler);
                  });
              })
              .Build()
              .Run();
            }

        static async Task PredictHandler(HttpContext http)
        {
            // Get PredictionEnginePool service
            var predictionEnginePool = http.RequestServices.GetRequiredService<PredictionEnginePool<SentimentModel.ModelInput, SentimentModel.ModelOutput>>();

            // Deserialize HTTP request JSON body
            var body = http.Request.Body as Stream;
            var input = await JsonSerializer.DeserializeAsync<SentimentModel.ModelInput>(body);

            // Predict
            SentimentModel.ModelOutput prediction = predictionEnginePool.Predict(input);

            // Return prediction as response
            await http.Response.WriteAsJsonAsync(prediction);
        }
    }
}
```

If you're familiar with ASP.NET Core conventions, you'll notice that that [`ConfigureServices`](https://docs.microsoft.com/aspnet/core/fundamentals/startup?view=aspnetcore-5.0#the-configureservices-method) and [`Configure`](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/startup?view=aspnetcore-5.0#the-configure-method) methods which are typically found inside of the *Startup.cs* file are part of the `Main` method in *Program.cs*.

> [!TIP]
> `PredictionEngine` is not thread-safe. Additionally, you have to create an instance of it everywhere it is needed within your application. As your application grows, this process can become unmanageable. For improved performance and thread safety, use a combination of dependency injection and the `PredictionEnginePool` service, which creates an `ObjectPool` of `PredictionEngine` objects for use throughout your application. See [dependency injection in ASP.NET Core](https://docs.microsoft.com/aspnet/core/fundamentals/dependency-injection) for more information.

The `PredictionEnginePool` service is configured in the to make it accessible throughotut he rest of the application usign dependency injection. 

Since you only need a single route to make predictions, in the `Configure` method, the `/predict` endpoint is defined to handle incoming HTTP POST requests as defined by the `PredictionHandler` method.

In the `PredictionHandler` method:

1. The application requests a `PredictionEnginePool`. 
1. The incoming JSON body of the request is deserialized into an object matching the schema of your input data. In this case, the type is `ModelInput`.
1. The `Predict` method of the `PredictionEnginePool` is used to make predictions on the input data.
1. The resulting prediction is returned as a JSON string.

## Next steps

- [Publish an ASP.NET Core app to Azure with Visual Studio](https://docs.microsoft.com/aspnet/core/tutorials/publish-to-azure-webapp-using-vs?view=aspnetcore-5.0#deploy-the-app-to-azure)